name: Android Rooting Module Validation

on:
  push:
    paths:
      - 'android_rooting/**'
      - 'install_android.sh'
      - 'launch_termux.sh'
      - 'termux_environment.py'
    branches: [ "main", "copilot/*" ]
  pull_request:
    paths:
      - 'android_rooting/**'
      - 'install_android.sh'
      - 'launch_termux.sh'
      - 'termux_environment.py'
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  validate-android-module:
    runs-on: ubuntu-latest
    name: Validate Android Rooting Module
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
        
    - name: Install Android SDK tools (for testing)
      run: |
        sudo apt-get update
        sudo apt-get install -y android-sdk-platform-tools-common
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest pytest-cov bandit
        # Install requirements if they exist
        if [ -f requirements.txt ]; then
          pip install -r requirements.txt
        fi
        
    - name: Create Android module validator
      run: |
        cat > validate_android_module.py << 'EOF'
        #!/usr/bin/env python3
        """
        Comprehensive validation for Android rooting module
        Ensures all components meet production standards
        """
        
        import os
        import re
        import ast
        import subprocess
        from pathlib import Path
        
        class AndroidModuleValidator:
            def __init__(self):
                self.android_root = Path('android_rooting')
                self.errors = []
                self.warnings = []
                self.info = []
                
                # Required module structure
                self.required_dirs = ['bots', 'core', 'utils', 'scripts', 'docs']
                self.required_files = [
                    '__init__.py',
                    'bots/__init__.py',
                    'core/__init__.py',
                    'utils/__init__.py'
                ]
                
            def validate_structure(self):
                """Validate Android module directory structure"""
                if not self.android_root.exists():
                    self.errors.append("Android rooting module directory missing")
                    return
                    
                # Check required directories
                for req_dir in self.required_dirs:
                    dir_path = self.android_root / req_dir
                    if not dir_path.exists():
                        self.warnings.append(f"Recommended directory missing: {req_dir}")
                    else:
                        self.info.append(f"Directory found: {req_dir}")
                        
                # Check required files
                for req_file in self.required_files:
                    file_path = self.android_root / req_file
                    if not file_path.exists():
                        self.errors.append(f"Required file missing: {req_file}")
                    else:
                        self.info.append(f"Required file found: {req_file}")
                        
            def validate_python_modules(self):
                """Validate Python modules in android_rooting"""
                for py_file in self.android_root.rglob('*.py'):
                    try:
                        # Check syntax
                        with open(py_file, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        try:
                            ast.parse(content)
                            self.info.append(f"Syntax OK: {py_file.relative_to(self.android_root)}")
                        except SyntaxError as e:
                            self.errors.append(f"Syntax error in {py_file}: {e}")
                            
                        # Check for bare except clauses
                        if re.search(r'except:\s*$', content, re.MULTILINE):
                            self.warnings.append(f"Bare except clause found in {py_file}")
                            
                        # Check for hardcoded paths
                        hardcoded_paths = re.findall(r'/data/data/com\.termux/files/usr', content)
                        if hardcoded_paths:
                            self.warnings.append(f"Hardcoded Termux paths in {py_file}: {len(hardcoded_paths)} instances")
                            
                        # Check for proper logging
                        if 'logging' not in content and 'logger' not in content and py_file.name != '__init__.py':
                            self.warnings.append(f"No logging implementation in {py_file}")
                            
                        # Check for References section
                        if 'References:' not in content and py_file.name != '__init__.py':
                            self.warnings.append(f"Missing References section in {py_file}")
                            
                    except Exception as e:
                        self.warnings.append(f"Could not validate {py_file}: {e}")
                        
            def validate_security_practices(self):
                """Validate security practices in Android module"""
                security_issues = []
                
                for py_file in self.android_root.rglob('*.py'):
                    try:
                        with open(py_file, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        # Check for potential security issues
                        if 'subprocess.run(' in content and 'shell=True' in content:
                            security_issues.append(f"Shell injection risk in {py_file}")
                            
                        if re.search(r'os\.system\(', content):
                            security_issues.append(f"os.system() usage in {py_file}")
                            
                        if re.search(r'eval\(', content):
                            security_issues.append(f"eval() usage in {py_file}")
                            
                        # Check for proper input validation
                        if 'input(' in content and 'validate' not in content.lower():
                            security_issues.append(f"Potential unvalidated input in {py_file}")
                            
                    except Exception as e:
                        self.warnings.append(f"Could not check security in {py_file}: {e}")
                        
                if security_issues:
                    self.warnings.extend(security_issues)
                else:
                    self.info.append("No obvious security issues found")
                    
            def validate_android_specific(self):
                """Validate Android-specific functionality"""
                android_features = {
                    'root_detection': False,
                    'magisk_integration': False,
                    'termux_compatibility': False,
                    'privilege_escalation': False,
                    'kali_integration': False
                }
                
                for py_file in self.android_root.rglob('*.py'):
                    try:
                        with open(py_file, 'r', encoding='utf-8') as f:
                            content = f.read().lower()
                            
                        if 'root' in content and ('detect' in content or 'check' in content):
                            android_features['root_detection'] = True
                            
                        if 'magisk' in content:
                            android_features['magisk_integration'] = True
                            
                        if 'termux' in content or 'com.termux' in content:
                            android_features['termux_compatibility'] = True
                            
                        if 'privilege' in content or 'escalat' in content:
                            android_features['privilege_escalation'] = True
                            
                        if 'kali' in content or 'chroot' in content:
                            android_features['kali_integration'] = True
                            
                    except Exception as e:
                        self.warnings.append(f"Could not check Android features in {py_file}: {e}")
                        
                # Report feature coverage
                found_features = [k for k, v in android_features.items() if v]
                missing_features = [k for k, v in android_features.items() if not v]
                
                self.info.append(f"Android features found: {', '.join(found_features)}")
                if missing_features:
                    self.warnings.append(f"Android features not detected: {', '.join(missing_features)}")
                    
            def validate_shell_scripts(self):
                """Validate shell scripts related to Android"""
                shell_scripts = ['install_android.sh', 'launch_termux.sh']
                
                for script in shell_scripts:
                    script_path = Path(script)
                    if script_path.exists():
                        try:
                            with open(script_path, 'r', encoding='utf-8') as f:
                                content = f.read()
                                
                            # Check for proper shebang
                            if not content.startswith('#!/'):
                                self.warnings.append(f"Missing shebang in {script}")
                                
                            # Check for error handling
                            if 'set -euo pipefail' not in content:
                                self.warnings.append(f"Missing 'set -euo pipefail' in {script}")
                                
                            # Check for Android/Termux specific patterns
                            if script == 'install_android.sh':
                                if 'pkg install' not in content and 'termux' in script.lower():
                                    self.warnings.append(f"No Termux package installation found in {script}")
                                    
                            self.info.append(f"Shell script validated: {script}")
                            
                        except Exception as e:
                            self.warnings.append(f"Could not validate {script}: {e}")
                    else:
                        self.warnings.append(f"Shell script not found: {script}")
                        
            def run_tests(self):
                """Run existing tests for Android module"""
                test_results = []
                
                # Look for test files
                test_files = list(Path('.').glob('test_android*.py'))
                
                if test_files:
                    for test_file in test_files:
                        try:
                            result = subprocess.run(['python', '-m', 'pytest', str(test_file), '-v'], 
                                                  capture_output=True, text=True, timeout=60)
                            
                            if result.returncode == 0:
                                test_results.append(f"✅ {test_file}: PASSED")
                            else:
                                test_results.append(f"❌ {test_file}: FAILED")
                                self.warnings.append(f"Test failures in {test_file}")
                                
                        except subprocess.TimeoutExpired:
                            test_results.append(f"⏰ {test_file}: TIMEOUT")
                            self.warnings.append(f"Test timeout in {test_file}")
                        except Exception as e:
                            test_results.append(f"❓ {test_file}: ERROR - {e}")
                            
                    self.info.extend(test_results)
                else:
                    self.warnings.append("No Android-specific test files found")
                    
            def generate_report(self):
                """Generate validation report"""
                report = "# Android Rooting Module Validation Report\n\n"
                
                # Summary
                total_issues = len(self.errors) + len(self.warnings)
                report += f"## 📊 Validation Summary\n\n"
                report += f"- ❌ Errors: {len(self.errors)}\n"
                report += f"- ⚠️ Warnings: {len(self.warnings)}\n"
                report += f"- ℹ️ Info: {len(self.info)}\n\n"
                
                if total_issues == 0:
                    report += "✅ **All validations passed** - Android module is healthy\n\n"
                
                # Errors
                if self.errors:
                    report += f"## ❌ Errors ({len(self.errors)})\n\n"
                    for error in self.errors:
                        report += f"- {error}\n"
                    report += "\n"
                    
                # Warnings
                if self.warnings:
                    report += f"## ⚠️ Warnings ({len(self.warnings)})\n\n"
                    for warning in self.warnings:
                        report += f"- {warning}\n"
                    report += "\n"
                    
                # Info
                if self.info:
                    report += f"## ℹ️ Information ({len(self.info)})\n\n"
                    for info in self.info:
                        report += f"- {info}\n"
                    report += "\n"
                    
                # Module Statistics
                if self.android_root.exists():
                    py_files = len(list(self.android_root.rglob('*.py')))
                    sh_files = len(list(Path('.').glob('*android*.sh'))) + len(list(Path('.').glob('*termux*.sh')))
                    
                    report += "## 📈 Module Statistics\n\n"
                    report += f"- Python files: {py_files}\n"
                    report += f"- Shell scripts: {sh_files}\n"
                    report += f"- Directories: {len([d for d in self.android_root.iterdir() if d.is_dir()])}\n"
                
                return report
                
            def run_validation(self):
                """Run all validation checks"""
                self.validate_structure()
                self.validate_python_modules()
                self.validate_security_practices()
                self.validate_android_specific()
                self.validate_shell_scripts()
                self.run_tests()
                
                return len(self.errors) == 0  # Return True if no errors
        
        if __name__ == "__main__":
            validator = AndroidModuleValidator()
            success = validator.run_validation()
            
            report = validator.generate_report()
            print(report)
            
            # Save report for artifact upload
            with open('android_validation_report.txt', 'w') as f:
                f.write(report)
                
            exit(0 if success else 1)
        EOF
        
    - name: Run Android module validation
      run: |
        python validate_android_module.py > android_validation_output.txt 2>&1 || true
        
    - name: Display validation results
      run: |
        echo "=== ANDROID ROOTING MODULE VALIDATION RESULTS ==="
        cat android_validation_output.txt
        
    - name: Run security scan on Android module
      run: |
        echo "=== RUNNING SECURITY SCAN ON ANDROID MODULE ==="
        bandit -r android_rooting/ -f txt > android_security_scan.txt 2>&1 || true
        echo "Security scan results:"
        cat android_security_scan.txt
        
    - name: Test Android environment detection
      run: |
        echo "=== TESTING ANDROID ENVIRONMENT DETECTION ==="
        if [ -f termux_environment.py ]; then
          python termux_environment.py > termux_test_output.txt 2>&1 || true
          echo "Termux environment test results:"
          cat termux_test_output.txt
        fi
        
    - name: Validate shell scripts
      run: |
        echo "=== VALIDATING ANDROID SHELL SCRIPTS ==="
        
        for script in install_android.sh launch_termux.sh; do
          if [ -f "$script" ]; then
            echo "Validating $script:"
            
            # Check shebang
            if head -1 "$script" | grep -q "^#!/"; then
              echo "  ✅ Proper shebang found"
            else
              echo "  ❌ Missing or improper shebang"
            fi
            
            # Check error handling
            if grep -q "set -euo pipefail" "$script"; then
              echo "  ✅ Proper error handling (set -euo pipefail)"
            else
              echo "  ⚠️ Missing 'set -euo pipefail'"
            fi
            
            # Check syntax with bash
            if bash -n "$script"; then
              echo "  ✅ Bash syntax OK"
            else
              echo "  ❌ Bash syntax errors"
            fi
            
            echo ""
          fi
        done
        
    - name: Upload validation artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: android-validation-reports
        path: |
          android_validation_output.txt
          android_validation_report.txt
          android_security_scan.txt
          termux_test_output.txt
        retention-days: 30
        
    - name: Comment on PR with validation results
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let validationResults = '';
          
          try {
            validationResults = fs.readFileSync('android_validation_output.txt', 'utf8');
          } catch (error) {
            validationResults = 'Android validation results not available';
          }
          
          const body = `## 📱 Android Rooting Module Validation Results
          
          This PR modifies the Android rooting module. The module has been automatically validated for functionality, security, and compliance.
          
          <details>
          <summary>Validation Report</summary>
          
          \`\`\`
          ${validationResults}
          \`\`\`
          
          </details>
          
          ### What This Validation Checks:
          - 🏗️ Module structure and organization
          - 🔍 Python syntax and code quality
          - 🔒 Security practices and potential vulnerabilities
          - 📱 Android-specific functionality
          - 🐚 Shell script validation
          - 🧪 Test execution
          
          ### Android Features Validated:
          - Root detection capabilities
          - Magisk integration
          - Termux compatibility
          - Privilege escalation methods
          - Kali Linux integration
          
          **Note:** This validation ensures the Android rooting module meets production standards for mobile penetration testing.
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });

# References:
# - Internal: /reference_vault/linux_kali_android.md#android-rooting
# - Internal: /reference_vault/PRODUCTION_GRADE_STANDARDS.md#testing-standards
# - External: Android Developer Guide — https://developer.android.com/guide
# - External: Termux Documentation — https://termux.dev/docs/